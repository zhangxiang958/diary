# node

## 进程相关
进程是代码的实体, 当我们的代码运行起来就是一个进程, 但是不意味着这个进程就是运行的, 进程有很多种状态.进程在运行时需要很多的资源比如 CPU 运转, IO 设备等.
```
echo 'hello world'
```
这个在 bash 里面打开就是一个进程, 如果用 node 来实现就是:
```
process.stdout.write('hello world');
```
每个进程相关都会有 pid, 所谓 pid 就是 process id, 用来区分不同进程的正整数.
```
process.stdout.write('' + process.pid);
```
前面加 '' 是因为 write 只能接收 buffer 或 string, 上面这段代码就会输出进程的 pid.
每次输出都会是不一样的 pid, 也就是说 pid 是由操作系统随机分配的, 一个程序运行两次会有两个不同的 pid.
对于一个进程来说, 除了 pid, 还会有 ppid, 也就是 parent process id, 就是父进程的 id, 就好比人类起源, 进程就是进程树, ppid node 就写不了了....
因为不支持获取 process.ppid, 在 9.2.0 版本以后才有, 但是 9 版本不稳定.
进程号为 1 的进程没有 ppid, 所有进程都来自同一个进程.
如果需要查看 pid, 可以通过 top 或者 ps 命令来看, ps aux 的 aux 参数可以让 ps 的信息更详细.
有了 pid, 我们就可以随时 kill 了, kill -9 pid, -num 是不同的信号.
进程一定会有对应的进程名, 其实进程名一般都是进程 argv 数组的第一个参数, 毫无
意外, node 进程的文件就是
```
process.argv[0];
```
所以我们很容易获取 node 进程的进程参数, 就是通过 process.argv, 前两个是定的, 第一个为 node, 第二个为当前执行文件路径.
参数只能是启动的时候赋值, 参数如果过多请使用配置文件.
进程标准输入输出 stdout, stdin, stderr, 他们都是返回一个对象.
```
process.stdin.pipe(process.stdout);
```
通过这些标准输入输出, 我们很容易就获取了键盘的输入和屏幕的输出.
进程并不是越多越好, 如果进程太多, 说明 cpu 切换进程上下文的次数增加, 那么系统系能也会下降很多.
进程有 7 种状态:
O 进程正在
R 等待运行状态
S 休眠状态
B
D
Z
## 前端工程化
如果要做一个构建工具, 首先需要思量的就是你是从哪里获取你要处理的文件, 好比你要打包 css 文件, js 文件, 那么从那个文件夹取好, 之前想的时候觉得是靠用户自觉, 但是这样不好, 总会有不守规矩的人, 所以最好用工具规定, 也就是说我们需要指定文件路径, 那么我们就最好将所有的路径放在一个文件里面.