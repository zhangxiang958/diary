 # node

#JavaScript 继承模式
在这篇文章里面, 我将会为你介绍 3 种不同的方式来实现 JavaScript 中的继承. 或许你会在其他语言中例如 Java 看到
关于类的继承方式是通过让一个类去继承一个超类的初始属性与方法, 而一个超类可以同时被多个子类继承.

这意味着, 在 Java 中, 一个对象是一个类的实例, 而这个类或许继承于其他的类, 但是在 JavaScript 中, 原生的继承方式是
通过原型继承, 也就是说一个对象继承于另一个对象.

##伪类继承
伪类继承模式的目的是在 JavaScript 中通过模仿 Java 或者类 C 背景的语言的继承方式实现继承的模式. 换言之, 我们需
要在伪类继承模式中实现让一个对象能够继承于一个类的类继承的方式.

所谓伪类模式就是通过 constructor 构造器函数与 new 操作符将另一个 constructor 构造器的原型对象与本身的原型对象
实现连接.

实现这个模式需要依靠以下两个步骤:
1. 创建一个构造器函数
2. 修改子类的原型对象指向父类的原型对象从而实现继承

```
/**
 * 修改 childObj 的原型对象指向为 parentObj 的原型对象
 **/
var extendObj = function(childObj, parentObj) {
    childObj.prototype = parentObj.prototype;
};

// human 基类
var Human = function() {};
// 继承属性或者方法
Human.prototype = {
    name: '',
    gender: '',
    planetOfBirth: 'Earth',
    sayGender: function () {
        alert(this.name + ' says my gender is ' + this.gender);
    },
    sayPlanet: function () {
        alert(this.name + ' was born on ' + this.planetOfBirth);
    }
};

// male 类
var Male = function (name) {
    this.gender = 'Male';
    this.name = 'David';
};
// 继承 human 类
extendObj(Male, Human);

// female 类
var Female = function (name) {
    this.name = name;
    this.gender = 'Female';
};
// 继承 human 类
extendObj(Female, Human);

// 创建实例对象
var david = new Male('David');
var jane = new Female('Jane');

david.sayGender(); // David says my gender is Male
jane.sayGender(); // Jane says my gender is Female

Male.prototype.planetOfBirth = 'Mars';
david.sayPlanet(); // David was born on Mars
jane.sayPlanet(); // Jane was born on Mars
```
正如我们期望的一样, 我们通过伪类继承实现了对象的继承, 然而, 我们可以看到, 这个模式存在着一些问题. 我们来看一下上面的
示例代码中的最后一行的打印结果, " Jane was born on Mars ", 我们的本意其实是想让结果为 " Jane was born on Earth ", 导致这个现象的原因就是我们修改 Male.prototype 的 planetOfBirth 属性为 "Mars", 而 Famle 的原型对象
与 Male 的原型对象通过上面实例代码的继承方式已经变为了同一个对象.

直接修改 Male 与 Human 原型对象的关系的问题就在于如果有很多子类继承于 human, 如果其中有一个子类的原型对象上的属性
或者方法被修改, 那么会影响到 Human 这个类还有继承于 Human 的所有子类. 原则上, 继承方式里面修改一个子类的属性不应该
应该到其他的继承于同一个父类的兄弟子类. 导致这个原因是因为在 JavaScript 中对象是引用传递而不是值传递, 这意味着 Human 的全部子类只要在原型对象上做修改, 其他子类都会受到影响.

childObj.prototype = parentObj.prototype; 确实能够简单地实现继承, 但是, 如果你想要避免上面所说的问题, 你需要
修改 extendObj 函数将之前修改 childObj 的原型对象直接指向 parentObj 原型对象改为通过生成一个新的对象 tmpObject 让
这个 tmpObject 对象的原型继承于 parentObj 原型对象, 然后让 childObj 的原型对象指向这个新的临时中间对象 tmpObject, 从而避免 childObj.prototype 与 parentObj.prototype 的直接连接.
通过每次调用继承函数 extendObj 都会创建一个新的空对像 tmpObject, 这样你就可以让这个新的空对像 tmpObject 的原型对象继承 Human 的所有属性而不会影响其他子类.

这样你就可以解决上面所述的那个引用传递导致的问题了, 我们通过使用一个新的空对像来继承于父类原型, 但是由于每个子类继承的时候都会创建一个新的中间对象来实现继承, 所以修改其中一个子类对象的原型对象不会影响其他子类的原型对象.

为了让你更明白, 下面这幅图展示了 extendObj 函数修改原型对象指向的逻辑:
[图]

现在, 如果你依照上面的步骤对 extendObj 函数进行修改之后再运行代码就会发现结果打印为 " Jane was born on Earth ":
```
/**
 * 创建一个新的构造器函数, 设置新的构造器函数的原型对象指向为 parentObj 的原型对象.
 * 然后设置 childObj 的原型对象指向为由刚刚创建的构造器函数创建出的实例对象.
 **/
var extendObj = function(childObj, parentObj) {
    var tmpObj = function () {}
    tmpObj.prototype = parentObj.prototype;
    childObj.prototype = new tmpObj();
    childObj.prototype.constructor = childObj;
};

// human 基类
var Human = function () {};
// 需要继承的属性与方法
Human.prototype = {
    name: '',
    gender: '',
    planetOfBirth: 'Earth',
    sayGender: function () {
        alert(this.name + ' says my gender is ' + this.gender);
    },
    sayPlanet: function () {
        alert(this.name + ' was born on ' + this.planetOfBirth);
    }
};

// male 类
var Male = function (name) {
    this.gender = 'Male';
    this.name = 'David';
};
// 继承自 Human
extendObj(Male, Human);

// female 类
var Female = function (name) {
    this.name = name;
    this.gender = 'Female';
};
// 继承自 Human
extendObj(Female, Human);

// 创建新的实例对象
var david = new Male('David');
var jane = new Female('Jane');

david.sayGender(); // David says my gender is Male
jane.sayGender(); // Jane says my gender is Female

Male.prototype.planetOfBirth = 'Mars';
david.sayPlanet(); // David was born on Mars
jane.sayPlanet(); // Jane was born on Earth
```

## 功能模式
另一个模式就是由 Douglas Crockford 发明的功能模式, 这个模式允许一个对象继承于另一个对象, 并在这基础上
对子对象进行增强. 也就是说, 你可以先创建一个对象作为父类, 然后通过传递子类的实例对象给父类并继承父类上的
属性与方法, 将返回的结果实例对象添加上子类特有的属性.
下面的代码伪类模式的示例代码, 但是是用功能模式来写的:
```
var human = function(name) {
    var that = {};

    that.name = name || '';
    that.gender = '';
    that.planetOfBirth = 'Earth';
    that.sayGender = function () {
        alert(that.name + ' says my gender is ' + that.gender);
    };
    that.sayPlanet = function () {
        alert(that.name + ' was born on ' + that.planetOfBirth);
    };

    return that;
}

var male = function (name) {
    var that = human(name);
    that.gender = 'Male';
    return that;
}

var female = function (name) {
    var that = human(name);
    that.gender = 'Female';
    return that;
}

var david = male('David');
var jane = female('Jane');

david.sayGender(); // David says my gender is Male
jane.sayGender(); // Jane says my gender is Female

david.planetOfBirth = 'Mars';
david.sayPlanet(); // David was born on Mars
jane.sayPlanet(); // Jane was born on Earth
```

我们可以看到, 在这个模式里面, 我们不需要操作原型链, 构造函数与 new 关键字来创建实例对象, 功能模式通过每次调用继承函数生成一个实例对象就生成一个新的对象来达到目的.

然而, 我们可以发现这个模式是有性能缺陷的, 每次创建实例对象都会去创建一个新的对象, 并且全部继承了父类的所有属性与方法, 实例对象与实例对象之间并没有可共享的属性, 这就导致 JavaScript 底层编译器在每次调用的时候就分配了新的内存空间来记录数据, 因为对象之间没有关联性.

当然, 这个模式也有好处, 就是由于使用函数来实现继承, 我们可以通过闭包来轻易地实现私有与公有属性方法的配置.我们来看一下下面这个两个子类 motorbike 与 boat 与父类 venicle 的关系的示例代码:
```
var vehicle = function(attrs) {
    var _privateObj = {
        hasEngine: true
    },
    that = {};

    that.name = attrs.name || null;
    that.engineSize = attrs.engineSize || null;
    that.hasEngine = function () {
        alert('This ' + that.name + ' has an engine: ' + _privateObj.hasEngine);
    };

    return that;
}

var motorbike = function () {

    // private
    var _privateObj = {
        numWheels: 2
    },

    // inherit
    that = vehicle({
        name: 'Motorbike',
        engineSize: 'Small'
    });

    // public
    that.totalNumWheels = function () {
        alert('This Motobike has ' + _privateObj.numWheels + ' wheels');
    };

    that.increaseWheels = function () {
        _privateObj.numWheels++;
    };

    return that;

};

var boat = function () {

    // inherit
    that = vehicle({
        name: 'Boat',
        engineSize: 'Large'
    });

    return that;

};

myBoat = boat();
myBoat.hasEngine(); // This Boat has an engine: true
alert(myBoat.engineSize); // Large

myMotorbike = motorbike();
myMotorbike.hasEngine(); // This Motorbike has an engine: true
myMotorbike.increaseWheels();
myMotorbike.totalNumWheels(); // This Motorbike has 3 wheels
alert(myMotorbike.engineSize); // Small

myMotorbike2 = motorbike();
myMotorbike2.totalNumWheels(); // This Motorbike has 2 wheels

myMotorbike._privateObj.numWheels = 0; // undefined
myBoat.totalNumWheels(); // undefined
```
我们可以看到这个模式很容易地就能封装私有与公有属性与方法, _private 对象不能在外部被修改, 它只能通过公有方法例如 increaseWheel() 这样的函数来修改.同样地, _private 对象也不能在外部读取数据, 只能通过公有的方法像 totalNumWheels 来读取值.

## 原型继承
你也可以直接只用 JavaScript 中的原型继承方法来实现继承, 其实这样的方法才是最适合 JavaScript 语言本身的.在 ECMAScript 5 中, 你可以像下面这样轻易地实现继承:
```
var male = Object.create(human);
```
但是, 浏览器对这个方法的支持率并不理想, 如果浏览器还不支持这个方法, 我们只能自己写一个 create 方法来实现继承了:
```
(function () {
    'use strict';

    /***************************************************************
     * Helper functions for older browsers
     ***************************************************************/
    if (!Object.hasOwnProperty('create')) {
        Object.create = function (parentObj) {
            function tmpObj() {}
            tmpObj.prototype = parentObj;
            return new tmpObj();
        };
    }
    if (!Object.hasOwnProperty('defineProperties')) {
        Object.defineProperties = function (obj, props) {
            for (var prop in props) {
                Object.defineProperty(obj, prop, props[prop]);
            }
        };
    }
    /*************************************************************/

    var human = {
        name: '',
        gender: '',
        planetOfBirth: 'Earth',
        sayGender: function () {
            alert(this.name + ' says my gender is ' + this.gender);
        },
        sayPlanet: function () {
            alert(this.name + ' was born on ' + this.planetOfBirth);
        }
    };

    var male = Object.create(human, {
        gender: {value: 'Male'}
    });

    var female = Object.create(human, {
        gender: {value: 'Female'}
    });

    var david = Object.create(male, {
        name: {value: 'David'},
        planetOfBirth: {value: 'Mars'}
    });

    var jane = Object.create(female, {
        name: {value: 'Jane'}
    });

    david.sayGender(); // David says my gender is Male
    david.sayPlanet(); // David was born on Mars

    jane.sayGender(); // Jane says my gender is Female
    jane.sayPlanet(); // Jane was born on Earth
})();
```

## 结论
我们已经讨论了三种在 JavaScript 中实现继承的方式.大多数人都只会使用原型继承, 但是我们可以看到伪类继承与功能模式也可以有用武之地.

不管你选择哪种方式都取决于你的实际情况, 还是那句话, "没有银弹", 所以你只需要根据你的实际情况作出最合适的方案选择就可以.